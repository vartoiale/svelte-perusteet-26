# Tehtävä 6 - heippa-komponentti, alikomponentilla, joka ottaa vastaan arvoja

**palautettavien tiedostojen nimet:** 

* `teht06.svelte` (kansiossa: `harjoitukset/02-javascript/01-svelte/teht06.svelte`)
* `alikomponentti06.svelte` (kansiossa: `harjoitukset/02-javascript/01-svelte/alikomponentti06.svelte`)

Funktioiden tapaan, komponenteille on mahdollista antaa kutsuttaessa arvoja.
Näitä arvoja kutsutaan englanninkielisellä termillä "props".
Tämä onnistuu kutsuttaessa käyttäen html:n attribuuttien syntaksia.

Eli jos halutaisiin antaa nimetty arvo `tervehdittävä` komponentille, 
tapahtuisi se komponentin käytön yhteydessä seuraavasti:

```svelte
<Komponentti tervehdittävä="Herra presidentti" />
```

Vastaavasti komponentti pääsee käsiksi sille annettuihin arvoihin seuraavasti:

```svelte
<script>
  let { tervehdittävä } = $props(); 
</script>
```

Mitä tässä siis tapahtuu:

1. `let { avain1, avain2 } = avain-arvo-taulu` on syntaksi, jolla avain-arvo -taulusta otetaan nimellä ulos avaimet `avain1` ja `avain2`. Tässä vaiheessa riittää siis tietää, että tällä saadaan käyttöön aaltosulkeiden sisällä määritelty attribuutin arvo javascriptin puolelle. Tähän palataan tarkemmin myöhemmin.
2. `$props` on svelten oma erikoisfunktio, jota kutsumalla saadaan haettua komponentin saamat props:it. Eli ne arvot, mitä sille on attribuutteina annettu.

Tehdään tätä varten siis kaksi svelte-tiedostoa: 

`teht06.svelte`:

```svelte
<script>
  import Alikomponentti from './alikomponentti06.svelte';
  let tervehdittava = "rouva varapresidentti"
</script>

<h1>Tervepä terve, {tervehdittävä}!</h1>
<Alikomponentti tervehdittävä={tervehdittava} />
```

`alikomponentti06.svelte`:

```svelte
<script>
  let { tervehdittävä } = $props(); 
</script>

<h2>Heippa vaan, {tervehdittävä}!</h2>
```

Näin pystymme siis ylemmässä komponentissa määrittämään, ketä alikomponentin pitäisi tervehtiä.
Samalla kuitenkin jätämme alikomponentin vastuulle toteuttaa itse tervehdyksen.

Tavallaan vanhempi ei siis tiedä muuta, kuin sen että se antaa lapselle tervehdittävän,
ja sen jälkeen se voi vain toivoa, että lapsikomponentti käyttää annettua attribuuttia johonkin järkevään - tässä
tapauksessa siis tervehdykseen.

## Mistä alikomponentti tietää `$props`:sta saatavan muuttujan nimen?

Kysymys: 

Miten sitten päätämme sen muuttujan nimen, jonka `$props`-muuttujasta destrukturointioperaatiolla** (engl. desctructuring) otamme käyttöömme? 

(** Jos destrukturointi ei ole tuttua, siitä löytyy lisää tietoa tämän sivun lopusta.)

Vastaus:

Muuttujan nimi, jonka `$props`-muuttujasta otamme käyttöön, vastaa vanhemmassa komponentissa elementin attribuuttina käytettyä nimeä.

Edellisessä esimerkissä `teht06.svelte`-tiedostossa käytimme `Alikomponentti`-komponenttia seuraavasti itsensäsulkevana elementtinä:

```svelte
<Alikomponentti tervehdittävä={tervehdittava} />
```

ja vastaavasti `alikomponentti06.svelte`-tiedostossa luimme `tervehdittävä`-muuttujan seuraavasti:

```svelte
<script>
  let { tervehdittävä } = $props(); 
</script>
```

Eli `$props`:ista otettavan muuttujan nimen tulee siis vastata komponentille annettua attribuutin nimeä. 

Huomaa, että komponentille annettu muuttuja oli asian selventämiseksi kirjoitettu yllä ilman ääkkösiä, kun taas attribuutti (tai props:i) oli kirjoitettu ääkkösillä.

### Filosofisempaa pohdimpaa kiinnostuneille: kumpi komponenteista päättää attribuutin nimen, antaja vai ottaja, vai käyttäjä vai määrittäjä?

Kumpi sitten lopulta määrittää props:in nimen? 

1. Käyttävä vanhempikomponentti, joka antaa arvon attribuutille, nimeten attribuutin, vaiko
2. alikomponentti, joka lukee arvon `$props`-muuttujasta?

Kysymys taitaa olla filosofinen. Alla olevaa tulkintaa ei tarvitse sisäistää, mutta se saattaa avata ajattelua tältä osin:

1. Yhtäältä alikomponentti itse päättää sen rajapinnan, josta se arvoja hyväksyy. Siis olettamalla, että `$props` sisältää `tervehdittävä`-avaimen, alikomponentti ilmoittaa hyväksyvänsä tämän nimisen attribuutin.
2. Toisaalta vanhempikomponentti ilmoittaa vanhemman oikeudella antavansa arvon juuri sen nimisenä attribuuttina.

Lopulta päätöksen tästä tekee ohjelmoija, joka päättää koodille käyttötarkoituksen.

### Attribuutin nimi on yleinen virhetilanne

Kannattaa myös huomioida, että kirjoitusvirheet attribuuttien/props:ien nimissä ovat yleinen virhetilanne.

Jos molemmissa komponenteissa attribuutin nimi ei ole kirjoitettu tismalleen samalla tavalla, data hukkuu matkalle. 

### Lopuksi sivuraide: Mikä destrukturointi?

Destrukturointi on javascriptin operaatio, jolla objektista voidaan ottaa muuttujaksi käyttöön jokin objektin avain.

Destrukturointi on niin sanottua "syntaktista sokeria" (engl. syntax sugar), tarkoittaen,
että saman operaation pystyy tekemään perinteisellä javascriptilla vähän pidemmällä koodin pätkällä.
Syntaktinen sokeri on siis näppärä apuri, jolla on mahdollista kirjoittaa pidempiä asioita vähän lyhyemmin.
Toki, jos ei tunne miten kyseinen sokeroitu syntaksi toimii, se saattaa aiheuttaa harmaita hiuksia.
Javascriptissä on verrattain paljon erilaisia operaatioita, jotka paljastuvat lähemmällä tutkiskelulla vain syntaktiseksi sokeriksi.

Vaan se puhtaasta sanallisesta teoriasta. Kokeillaan destrukturointia

#### Destrukturoidaan käytännössä

Oletetaan, että meillä on objekti:

```js
let olio = {
  ekaAvain: 1,
  tokaAvain: 2,
}
```

Jos haluaisimme ottaa tästä objektista avaimet (`ekaAvain` ja `tokaAvain`) muuttujiksi, 
ja sijoittaa niihin niitä objektissa vastaavat arvot, 
se on mahdollista tehdä perinteisellä javascriptillä seuraavasti,
ilman destrukturointia:

```js
let ekaAvain = olio.EkaAvain;
let tokaAvain = olio.tokaAvain;
```

Aikaisen yksinkertaista, ja kivutonta. Koko komeudessaan tämä operaatio onnistui kahdella koodirivillä.

Miten sitten tekisimme saman destrukturointia käyttäen:

```js
let { ekaAvain, tokaAvain } = olio;
```

Destrukturointi siis säästää meiltä tässä tapauksessa yhden rivin.

Nämä molemmat koodiesimerkit tekevät kuitenkin saman asian.
Niiden jälkeen meillä on käytössä kaksi uutta muuttujaa (`ekaAvain` ja `tokaAvain`), 
täsmälleen samoilla muuttujanarvoilla.

Mitä hyötyä tästä nyt sitten on? Yhden rivin säästöstäkö tässä on kyse?

#### Destrukturoinnin edut ja vaihtokaupat

##### Destrukturoinnin edut

Edut tulevat nopeasti ilmi, jos meillä onkin isompi objekti käytössä, 
josta haluamme ottaa useamman muuttujan käyttöön.

Oletetaan

```js
let aakkosOlio = {
  a: 1,
  b: 2,
  c: 3,
  d: 4,
  e: 5,
  f: 6,
  g: 7,
  // ... jne
}
```

Tällöin perinteinen menetelmä kasvaa moniriviseksi:

```js
let a = aakkosOlio.a;
let b = aakkosOlio.b;
let c = aakkosOlio.c;
let d = aakkosOlio.d;
let e = aakkosOlio.e;
let f = aakkosOlio.f;
```

Destrukturointi vie kuitenkin edelleen vain yhden rivin:

```js
let { a, b, c, d, e, f } = aakkosOlio;
```

##### Destrukturoinnin vaihtokaupat

Destrukturointi ei kuitenkaan sovi aivan kaikkiin tapauksiin.

Yksi tällainen esimerkki on, jos haluammekin antaa uudelle muuttujalle toisen nimen.

Oletetaan objekti:

```js
let kalaOlio = {
  hauki: "on kala",
};
```

Tällöin perinteisellä tavalla erinimiseen muuttujaan tiedon siirto menee seuraavasti:

```js
let kuha = kalaOlio.hauki
```

Tämä on aika selvää, ja myös lukijalle ihan ystävällistä.

Destruktrutointikin taipuu tähän, mutta se menee vähän ehkä vaikealukuisammaksi:

```js
let {hauki:kuha} = kalaOlio
```

Ja mitäs siinä siis tapahtuikaan. No ihan selvästi sama asia kuin edellisessä esimerkissä.

Joskus tämäkin saattaa olla ihan näppärä syntaksiltaan:

```js
let { a, b, c, d:D, e } = aakkosOlio;
```

Tai sitten ei.

## Seuraavaksi

Seuraavaksi lopetellaan tehtäväsarja 1 ja siirrytään isompaan projektiin.

Seuraavaksi: [Tehtäväsarja 1: seuraavaksi](./01-07-seuraavaksi.md)
